# JavaScript基礎

JavaScriptは、動的で柔軟な言語であり、Web開発に広く使用されています。
JavaScriptの基礎となる概念を以下に示します。

1. 変数：JavaScriptでは、値を保存するために変数を使用します。変数を宣言するには、var、let、またはconstを使用します。
2. データ型：JavaScriptには、プリミティブ型（数値、文字列、真偽値、null、undefined）とオブジェクト型（配列、関数、オブジェクト）の2つのデータ型があります。
3. 制御構造：JavaScriptには、条件分岐（if、else if、else）、ループ（for、while）、switch文などの制御構造があります。
4. 関数：JavaScriptでは、関数を定義して再利用可能なコードを作成できます。関数には引数と戻り値があります。
5. イベント：JavaScriptを使用して、ユーザーのアクション（クリック、マウスオーバー、キーボード入力など）に対する処理を記述できます。
6. オブジェクトとプロパティ：JavaScriptでは、オブジェクトを使用して関連するデータをグループ化できます。オブジェクトには、プロパティと値があります。
7. クラス：ES6以降、JavaScriptにはクラスが導入され、オブジェクト指向プログラミングがサポートされました。
8. DOM：JavaScriptを使用して、HTML要素の取得、追加、削除、変更など、Webページのドキュメントオブジェクトモデル（DOM）を制御できます。

## 1. 変数

JavaScriptには、変数を使ってデータを保持することができます。

### 変数キーワード

変数はvar, let, constキーワードを使って宣言します。

```
var text = "sample text";
let message = "Hello, World!";
const pi = 3.14159;
```

**var**

varは、ES5以前のJavaScriptで利用されていた変数宣言のキーワードです。varで宣言した変数は、スコープが関数レベルのため、関数の内側で宣言された変数は、関数内でのみアクセス可能です。また、varで宣言された変数は、同じ名前の変数を再度宣言できてしまい、変数の値を上書きできてしまいます。

```
function myFunction() {
  var x = 1;
  if (true) {
    var x = 2;
    console.log(x); // 2
  }
  console.log(x); // 2
}

myFunction();
```

**let**
letは、ES6で導入されたブロックレベルのスコープを持つ変数宣言のキーワードです。letで宣言された変数は、そのブロック内でのみアクセス可能です。また、同じ名前の変数を再度宣言することはできませんが、変数の値を再代入することができます。

```
function myFunction() {
  let x = 1;
  if (true) {
    let x = 2;
    console.log(x); // 2
  }
  console.log(x); // 1
}

myFunction();
```

**const**

constは、ES6で導入されたブロックレベルのスコープを持つ定数宣言のキーワードです。constで宣言された変数は、そのブロック内でのみアクセス可能です。また、同じ名前の変数を再度宣言することはできませんし、再代入もできません。定数を宣言する場合に使用します。

```
function myFunction() {
  const x = 1;
  if (true) {
    const x = 2;
    console.log(x); // 2
  }
  console.log(x); // 1
}

myFunction();
```

ただし、オブジェクトや配列といった参照型のデータをconstで宣言した場合でも、その値を再代入することはできませんが、オブジェクトや配列自体のプロパティを変更することはできます。

```
const person = { name: "John", age: 30 };
person.age = 40; // OK
person = { name: "Alice", age: 20 }; // エラー
```

### 変数宣言

変数を宣言するときには、初期値を設定する必要はありませんが、
変数を使用する前に初期値が設定されている必要があります。

初期値が設定されていない場合、変数の値はundefinedになります。

```
let myVar;
console.log(myVar); // undefined

myVar = 10;
console.log(myVar); // 10
```

## 2. データ型

JavaScriptには、以下のようなデータ型があります。

文字列: "Hello, World!"

数値: 42

真偽値: trueまたはfalse

undefined: 変数に値が割り当てられていない状態

null: 変数にnullという値を明示的に代入した状態

オブジェクト: { name: "John", age: 30 }

配列: [1, 2, 3]

以下、それぞれのデータ型について説明します。

### 文字列
文字列は、文字や記号の集合を表します。

文字列は、シングルクォーテーション'またはダブルクォーテーション"で囲みます。

また、バッククォート``を使用すると、複数行にわたる文字列を表現することができます。

```
let name = "Alice";
let message = "Hello, " + name + "!";
let multiLine = `Hello,
World!`;
```

### 数値

数値は、整数や小数点以下の数を表します。

```
let x = 42;
let y = 3.14;
```

### 真偽値

真偽値は、trueまたはfalseの値を表します。

真偽値は、比較演算子や論理演算子の結果として返されることが多いです。

```
let x = 5;
let y = 10;
let result = x < y; // true
```

### undefined

undefinedは、変数に値が割り当てられていない状態を表します。

未定義の変数を参照した場合、その変数はundefinedになります。

```
let x;
console.log(x); // undefined
```

### null

nullは、変数にnullという値を明示的に代入した状態を表します。

```
let x = null;
console.log(x); // null
```

### オブジェクト

オブジェクトは、キーと値のペアで構成される複合データ型です。

オブジェクトは、波括弧{}で囲んで表現します。

```
let person = { name: "John", age: 30 };
console.log(person.name); // John
console.log(person.age); // 30
```

### 配列

配列は、複数の値を順番に格納することができます。

配列は、角括弧[]で囲んで表現します。

```
let fruits = ["apple", "banana", "orange"];
console.log(fruits[0]); // apple
console.log(fruits[1]); // banana
console.log(fruits[2]); // orange
```

## 3. 制御構造
JavaScriptには、制御構造と呼ばれる文法があります。これらの構造を使用することで、条件分岐や繰り返し処理を行うことができます。

### 条件分岐

**if文**
if文は、条件式がtrueの場合に、指定された文を実行する制御構造です。

```
if (条件式) {
  // 条件式が true の場合に実行する文
}
```

**if-else文**
if-else文は、条件式がtrueの場合には指定された文を実行し、そうでない場合には別の文を実行する制御構造です。

```
if (条件式) {
  // 条件式が true の場合に実行する文
} else {
  // 条件式が false の場合に実行する文
}
```

**else-if文**
else-if文は、複数の条件式を判定するために使用され、最初にif文が評価され、その後の条件が評価されます。

```
if (条件式1) {
  // 条件式1が true の場合に実行する文
} else if (条件式2) {
  // 条件式2が true の場合に実行する文
} else if (条件式3) {
  // 条件式3が true の場合に実行する文
} else {
  // いずれの条件式も false の場合に実行する文
}
```

### 三項演算子
三項演算子は、条件分岐を1行で書くことができます。

以下のような構文になります。

```
条件式 ? trueの場合の文 : falseの場合の文
```

例えば、次のような式は、xが10以下の場合は'10以下'を返し、そうでない場合は'10より大きい'を返します。

```
var result = x <= 10 ? '10以下' : '10より大きい';
```

三項演算子を使用すると、簡潔で読みやすいコードを書くことができますが、
ネストが深くなると可読性が悪くなることがあるため、注意が必要です。

### 繰り返し処理

**while文**
while文は、指定された条件がtrueである限り、繰り返し処理を行う制御構造です。

以下の構文を持ちます。

```
while (条件式) {
  // 繰り返し実行する文
}
```

例えば、1から10までの数値を順番に表示する場合、以下のように書くことができます。

```
var i = 1;
while (i <= 10) {
  console.log(i);
  i++;
}
```


**do-while文**
do-while文は、while文と似ていますが、条件式の評価が後ろに来る点が異なります。つまり、最初に1回だけ繰り返し処理を行い、その後に条件式を評価します。

以下の構文を持ちます。

```
do {
  // 繰り返し実行する文
} while (条件式);
```

例えば、1から10までの数値を順番に表示する場合、以下のように書くことができます。

```
var i = 1;
do {
  console.log(i);
  i++;
} while (i <= 10);
```

do-while文は、繰り返し処理を最低でも1回は行う必要がある場合に便利です。


**for文**
for文は、指定された回数だけ繰り返し処理を行う制御構造です。

以下の構文を持ちます。

```
for (初期化式; 条件式; 更新式) {
  // 繰り返し実行する文
}
```

- 初期化式: 繰り返し処理を開始する前に1回だけ実行される式です。一般的には、カウンター変数を初期化するために使用されます。例えば、var i = 0;のように記述します。
- 条件式: 繰り返し処理が継続されるかどうかを判定するための式です。条件式がtrueの場合、繰り返し処理が実行されます。例えば、i < 10のように記述します。
- 更新式: 繰り返し処理の最後に1回だけ実行される式です。一般的には、カウンター変数を更新するために使用されます。例えば、i++のように記述します。

例えば、1から10までの数値を順番に表示する場合、以下のように書くことができます。

```
for (var i = 1; i <= 10; i++) {
  console.log(i);
}
```

**for-in文**
for-in文は、オブジェクトのプロパティを列挙するためのループです。以下の構文を持ちます。

```
for (var 変数名 in オブジェクト) {
  // プロパティに対する処理
}
```

for-in文は、オブジェクトのキー（プロパティ名）を順番に取り出して、そのキーに対応する値にアクセスします。

例えば、以下のように記述します。

```
var obj = { a: 1, b: 2, c: 3 };
for (var key in obj) {
  console.log(key, obj[key]);
}
```

この場合、objオブジェクトのキーを順番に取り出して、そのキーに対応する値を表示します。

結果は、以下のようになります。

```
a 1
b 2
c 3
```

注意点として、for-in文は、オブジェクトのプロトタイプチェーンも列挙するため、予期しない動作を引き起こすことがあります。
そのため、オブジェクトのプロパティを列挙する場合は、 `hasOwnProperty()メソッド` を使用して、プロトタイプチェーンを排除することが推奨されています。

**for-of文**
for-of文は、配列や文字列などの反復可能なオブジェクトを繰り返し処理するためのループです。

以下の構文を持ちます。

```
for (var 変数名 of 反復可能なオブジェクト) {
  // 要素に対する処理
}
```

for-of文は、配列や文字列などの要素を順番に取り出して、その要素に対応する値にアクセスします。

例えば、以下のように記述します。

```
var arr = [1, 2, 3];
for (var value of arr) {
  console.log(value);
}
```

この場合、arr配列の要素を順番に取り出して、その値を表示します。

結果は、以下のようになります。

```
1
2
3
```

for-of文は、反復可能なオブジェクトに対してしか使用できないため、オブジェクトの場合はfor-in文を使用する必要があります。

また、for-of文は、ECMAScript 6から導入されたため、古いブラウザでは動作しません。

## 4. 関数

JavaScriptにおける関数は、プログラムの中で繰り返し利用される処理をまとめたもので、再利用性や可読性を高めるために使われます。

関数は、以下のように定義します。

```
function 関数名(引数1, 引数2, ...) {
  // 処理
  return 戻り値;
}
```

ここで、関数名は関数の名前、引数1、引数2などは関数に渡す引数の名前であり、処理は関数内で実行される処理、戻り値は関数から返される値です。

以下は、簡単な足し算を行う関数の例です。

```
function add(a, b) {
  return a + b;
}
var result = add(1, 2); // 3
```

この関数を呼び出すと、引数に渡した2つの数値を足した結果が返されます。

また、関数は変数に代入することもできます。これを `無名関数（匿名関数）` と呼びます。

```
var add = function(a, b) {
  return a + b;
};

var result = add(1, 2); // 3
```

関数の中で定義された変数は、関数の外からアクセスすることができません。これをスコープと呼びます。スコープについては、関数スコープとブロックスコープの2つがあります。

関数スコープは、関数内で定義された変数が関数内でのみ有効で、関数外からはアクセスできないことを指します。一方、ブロックスコープは、ブロック（{}）内で定義された変数が、そのブロック内でのみ有効で、ブロック外からはアクセスできないことを指します。しかし、ES6からはletやconstといったブロックスコープの変数定義方法が導入され、より細かいスコープの定義が可能になりました。

また、関数は、他の関数の中で定義することもできます。これをネストした関数と呼びます。ネストした関数は、外側の関数のスコープにアクセスできるため、外側の関数で定義された変数を参照することができます。

以下は、ネストした関数の例です。

```
function outer() {
  var a = 1;
  function inner() {
    var b = 2;
    return a + b;
  }
  return inner();
}

var result = outer(); // 3
```

この例では、outer関数の中でaという変数が定義され、inner関数の中でbという変数が定義されています。inner関数はa + bを返すため、outer関数を呼び出すと、3が返されます。

また、関数はオブジェクトの一種であるため、関数にもプロパティを持つことができます。

以下は、関数にプロパティを追加する例です。

```
function add(a, b) {
  return a + b;
}

add.name; // "add"
add.description = "This function returns the sum of two numbers.";
add.description; // "This function returns the sum of two numbers."
```

ここでは、nameプロパティには関数の名前が、descriptionプロパティには関数の説明文が追加されています。プロパティは、ドット演算子またはブラケット演算子を使ってアクセスすることができます。

### アロー関数

JavaScriptには、アロー関数と呼ばれる、短くシンプルな関数を記述するための構文があります。アロー関数は、functionキーワードを使用せずに、矢印 `=>` を使って定義されます。

以下は、アロー関数の例です。

```
// 通常の関数の定義
function add(a, b) {
  return a + b;
}

// アロー関数による同じ関数の定義
const add = (a, b) => {
  return a + b;
}
```

アロー関数は、通常の関数と同様に、引数を受け取り、処理を実行し、結果を返すことができます。また、引数が一つしかない場合は、引数リストの丸括弧を省略することができます。

```
const square = x => {
  return x * x;
}

square(5); // 25
```

さらに、アロー関数が単一の式である場合、中括弧とreturnキーワードを省略することができます。この場合、式の評価結果が自動的に関数の戻り値になります。

```
// アロー関数による同じ関数の定義（短縮版）
const add = (a, b) => a + b;

// アロー関数による同じ関数の定義（引数が1つの場合の短縮版）
const square = x => x * x;
```

アロー関数は、関数の定義を簡潔にし、コードを読みやすくするために頻繁に使用されます。ただし、アロー関数が持つthisの挙動は通常の関数と異なるため、注意が必要です。詳細については、thisキーワードに関する知識が必要です。

### thisキーワード
JavaScriptのthisキーワードは、関数が呼び出されたときに、その関数を呼び出したオブジェクトを参照するために使用されます。thisは、関数内で使用される場所やコンテキストによって異なる値を持つことがあります。

以下は、thisキーワードの例です。

```
const person = {
  name: "Alice",
  sayHello: function() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

person.sayHello(); // "Hello, my name is Alice."
```

上記の例では、thisキーワードは、personオブジェクトを参照します。

つまり、sayHelloメソッドを呼び出すときに使用されたオブジェクトです。

しかし、thisキーワードは、functionキーワードで定義された関数内では、グローバルオブジェクトを参照します。

```
function sayHello() {
  console.log(`Hello, my name is ${this.name}.`);
}

const person = {
  name: "Alice",
  sayHello: sayHello
}

sayHello(); // "Hello, my name is undefined." （this.name はグローバルオブジェクトに定義されていないため undefined）
person.sayHello(); // "Hello, my name is Alice."
```

また、アロー関数内でのthisの値は、アロー関数が定義されたコンテキストによって決まります。アロー関数内でのthisは、アロー関数が定義された時点でのthisと同じになります。

```
const person = {
  name: "Alice",
  sayHello: function() {
    const innerFunction = () => {
      console.log(`Hello, my name is ${this.name}.`);
    }
    innerFunction();
  }
}

person.sayHello(); // "Hello, my name is Alice."
```

上記の例では、innerFunctionはアロー関数で定義されており、その中でのthisは、personオブジェクトを参照します。これは、アロー関数が定義されたコンテキストであるsayHelloメソッドのthisがpersonオブジェクトであるためです。

## 5. イベント
JavaScriptにおけるイベントは、Webページのユーザーインタラクションに応答して実行されるコードの断片です。イベントは、ボタンクリック、マウスオーバー、フォーム送信、ページ読み込みなどのアクションに関連して発生します。

### イベントの種類

JavaScriptで使用できる一般的なイベントには、以下のものがあります。

- click: 要素がクリックされたときに発生するイベントです。例えば、ボタンがクリックされたときや、リンクがクリックされたときに使用されます。
- mouseover: 要素がマウスオーバーされたときに発生するイベントです。マウスが要素の上に移動するときに使用されます。
- mouseout: 要素からマウスが離れたときに発生するイベントです。マウスが要素の外に移動するときに使用されます。
- keydown: キーボードのキーが押されたときに発生するイベントです。キーが押された状態を検知したい場合に使用されます。
- keyup: キーボードのキーが離されたときに発生するイベントです。キーが離された状態を検知したい場合に使用されます。
- input: テキストボックスやテキストエリアなどの入力要素の値が変更されたときに発生するイベントです。入力された値を取得したい場合に使用されます。
- submit: フォームが送信されたときに発生するイベントです。フォームの送信前に処理を実行するなどの場合に使用されます。

### イベントリスナーの追加
イベントを処理するために、イベントリスナーを追加する必要があります。これは、DOM要素に対して行われます。DOM要素には、HTMLのボタン、リンク、テキストボックスなどが含まれます。イベントリスナーは、addEventListener()メソッドを使用して追加されます。

以下は、ボタンクリックイベントの例です。

```
<input type="button" value="Button" id="myButton" />

<script>
    const button = document.querySelector('#myButton');

    button.addEventListener('click', function() {
        console.log('Button clicked!');
    });
</script>
```

上記の例では、querySelector()メソッドを使用して、myButton IDを持つボタンを取得し、addEventListener()メソッドを使用して、clickイベントが発生した場合に実行される関数を指定しています。

### イベントハンドラーの作成
イベントが発生した場合に実行される関数を作成する必要があります。これは、イベントリスナーで指定されます。関数は、イベントが発生した場合に実行されるコードを含みます。

例えば、以下は、テキストボックスの値が変更されたときに、その値を表示するイベントハンドラーの例です。

```
<h2 id="view">Text box value changed to </h2>
<input type="text" id="myTextBox" />

<script>
    const textBox = document.querySelector('#myTextBox');

    textBox.addEventListener('input', function () {
        document.querySelector('#view').innerText = `Text box value changed to ${textBox.value}`;
    });
</script>
```

上記の例では、querySelector()メソッドを使用して、myTextBox IDを持つテキストボックスを取得し、addEventListener()メソッドを使用して、inputイベントが発生した場合に実行される関数を指定しています。

### イベントの削除
イベントリスナーを削除する必要がある場合は、removeEventListener()メソッドを使用します。

```
<input type="button" id="myButton" value="myButton" />
<input type="button" id="eventDelete" value="eventDelete" />

<script>
    const button1 = document.querySelector('#myButton');

    button1.addEventListener('click', sayHello);

    const button2 = document.querySelector('#eventDelete');

    button2.addEventListener('click', function () {
        alert("event delete");
        button1.removeEventListener('click', sayHello);
    });

    function sayHello() {
        alert("Hello");
    }
</script>
```

上記の例では、clickイベントのリスナーを削除しています。

## 6. オブジェクトとプロパティ
JavaScriptにおけるオブジェクトは、関連する値と関数をグループ化したものです。JavaScriptのオブジェクトは、{}を用いて作成することができます。以下は、空のオブジェクトを作成する例です。

```
const myObj = {};
```

オブジェクトには、プロパティと呼ばれる値や関数を含めることができます。プロパティは、名前と値のペアで構成されます。プロパティ名は文字列であり、値には、文字列、数値、真偽値、オブジェクト、関数などを指定することができます。

以下は、プロパティを持つオブジェクトを作成する例です。

```
const myObj = {
  name: 'John',
  age: 30,
  isStudent: false,
  sayHello: function() {
    console.log('Hello!');
  }
};
```

この例では、name、age、isStudentという名前のプロパティを持ち、それぞれの値には文字列、数値、真偽値を指定しています。また、sayHelloという名前のプロパティには、関数を指定しています。

オブジェクトのプロパティにアクセスするには、ドット（.）またはブラケット（[]）を使用します。

以下は、オブジェクトのプロパティにアクセスする例です。

```
const myObj = {
  name: 'John',
  age: 30
};

console.log(myObj.name); // John
console.log(myObj['age']); // 30
```

この例では、ドットを使用してnameプロパティにアクセスし、ブラケットを使用してageプロパティにアクセスしています。また、プロパティに値を割り当てることもできます。

以下は、プロパティに値を割り当てる例です。

```
const myObj = {
  name: 'John',
  age: 30
};

myObj.name = 'Bob';
myObj['age'] = 40;

console.log(myObj.name); // Bob
console.log(myObj.age); // 40
```

この例では、nameプロパティに新しい値を割り当て、ageプロパティにも新しい値を割り当てています。


## 7. クラス

## 8. DOM
